Task 2.1 - Explanation of the SIZE Macro:

The SIZE macro from mm.c:
#define SIZE(p) (size_t)((uintptr_t)GET_NEXT(p) - (uintptr_t)(p + 1))

Let's break down how this macro works:

1. Input: p is a pointer to a BlockHeader structure

2. Operation:
   - (p + 1): Points to the memory right after the header (where user data begins)
   - GET_NEXT(p): Gets pointer to the next block's header
   - Both are cast to uintptr_t for pointer arithmetic
   - The subtraction gives us the size of usable space

3. Example:
   Memory at 0x100:
   [Header A] (p points here)
   [User Data Start] ((p + 1) points here, at 0x108)
   ... user data ...
   [Header B] (GET_NEXT(p) points here, at 0x128)

   SIZE(p) = 0x128 - 0x108 = 0x20 (32 bytes)

4. Why it works:
   - The subtraction of addresses gives us the exact number of bytes
     between the start of user data and the next header
   - This represents the actual space available for user data
   - The cast to size_t ensures we get a positive size value

Task 1.2 - Memory Layout After Initialization:
[Memory Start 0x100]
+----------------+
| Header 1       |  0x100
| next: 0x138    |
| free: 1        |
+----------------+
| Free Space     |  0x108-0x137
| (48 bytes)     |
+----------------+
| Header 2       |  0x138
| next: 0x100    |
| free: 1        |
+----------------+
[Memory End 0x140]

Task 1.3 - Why Hex Numbers Ending in 0 or 8 are Divisible by 8:

In hexadecimal:
1. Each digit represents 4 bits
2. Last digit 0 = 0000 in binary
   Last digit 8 = 1000 in binary

3. For 8-byte alignment, the last 3 bits must be 000
   - Numbers ending in 0: xxxx xxx0 (last 3 bits are 000)
   - Numbers ending in 8: xxxx xxx8 (last 3 bits are 000)

4. Since 8 = 2Â³, any number whose last 3 bits are 000 is divisible by 8
   Therefore, hex numbers ending in 0 or 8 are always 8-byte aligned.

Task 1.4 - Memory Layout After Allocations:
[Memory Start 0x100]
+----------------+
| Header A       |  0x100
| next: 0x128    |
| free: 0        |
+----------------+
| Block A        |  0x108-0x127
| (32 bytes)     |
+----------------+
| Header B       |  0x128
| next: 0x150    |
| free: 0        |
+----------------+
| Block B        |  0x130-0x14F
| (32 bytes)     |
+----------------+
| Header C       |  0x150
| next: 0x178    |
| free: 0        |
+----------------+
| Block C        |  0x158-0x177
| (32 bytes)     |
+----------------+
| Dummy Header   |  0x178
| next: 0x100    |
| free: 1        |
+----------------+
[Memory End 0x180]

Task 1.5 - Memory Layout Explanation:

1. Initial State:
   - Memory region starts at 0x100 and ends at 0x180
   - Headers are 8-byte aligned (addresses end in 0 or 8)
   - Initially contains two headers with one free block

2. Block Allocation:
   - Each header is followed by its user data block
   - Headers maintain a circular linked list structure
   - The dummy header at 0x178 points back to 0x100
   - All addresses follow natural progression

3. Memory Organization:
   - Headers are 8 bytes each
   - User blocks start immediately after headers
   - Each allocated block is 32 bytes
   - The dummy header marks the end of usable memory
   - Placed at 0x178 to stay within 0x180 memory limit
